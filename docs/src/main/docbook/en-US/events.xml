<?xml version="1.0" encoding="UTF-8"?>
<!--
  JBoss, Home of Professional Open Source
  Copyright 2010, Red Hat Middleware LLC, and individual contributors
  by the @authors tag. See the copyright.txt in the distribution for a
  full listing of individual contributors.

  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
--> 
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
   "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" []>
<chapter id="events">
   <title>Servlet event propagation</title>
   <para>
      By including the Seam 3 Servlet module in your web application (and performing the necessary listener
      configuration for pre-Servlet 3.0 environments) you will also have the servlet lifecycle events propagated to the
      CDI event bridge so you can observe them in your beans. Seam Servlet also fires some additional lifecycle events
      not offered by the Servlet API, such as when the response is initialized and destroyed.
   </para>

   <section id="events.servlet_context_lifecycle_listener">
      <title>Servlet context lifecycle listener</title> 
      <para>
         These events correspond to the <literal>javax.servlet.ServletContextListener</literal> interface.  The event
         object fired is a <literal>javax.servlet.ServletContext</literal> (since that's the only relevant information
         in the <literal>javax.servlet.ServletContextEvent</literal> object). There are two qualifiers available that
         can be used for selecting the lifecycle phase of the servlet context (initialize or destroy).
      </para>
      <para>
         <informaltable>
            <tgroup cols="2">
               <colspec colnum="1" colwidth="1*" />
               <colspec colnum="2" colwidth="3*" />
               <thead>
                  <row>
                     <entry>Qualifier</entry>
                     <entry>Description</entry>
                  </row>
               </thead>
               <tbody>
                  <row>
                     <entry>@Initialized</entry>
                     <entry>Qualifies the creation event</entry>
                  </row>
                  <row>
                     <entry>@Destroyed</entry>
                     <entry>Qualifies the destruction event</entry>
                  </row>
               </tbody>
            </tgroup>
         </informaltable>
      </para>
      <para>
         If you want to listen to both lifecycle events, leave out the qualifiers:
      </para>
      <programlisting role="JAVA"><![CDATA[public void observeServletContext(@Observes ServletContext ctx) {
   // Do something with the "servlet context" object
}]]></programlisting>
      <para>
         If you are interested in only a particular one, use a qualifer:
      </para>
      <programlisting role="JAVA"><![CDATA[public void observeServletContextInitialized(@Observes @Initialized ServletContext ctx) {
   // Do something with the "servlet context" object upon initialization
}]]></programlisting>
      <para>
         The name of the observer method is insignificant.
      </para>
   </section>

   <section id="events.application_initialization">
      <title>Application initialization</title>
      <para>
         The <literal>ServletContext</literal> initialized event provides an excellent opportunity to perform startup
         logic as an alterative to using an EJB 3.1 startup singleton. Even better, you can configure the bean to be
         destroyed immediately following the initialization routine by leaving it as dependent scoped (dependent-scoped
         observers only live for the duration of the observe method invocation).
      </para>
      <para>
         Here's an example of entering seed data into the database in a development environment (as indicated by a
         stereotype annotation named <literal>@Development</literal>).
      </para>
      <programlisting role="JAVA"><![CDATA[@Stateless
@Development
public class SeedDataImporter {
   @PersistenceContext
   private EntityManager em;

   public void loadData(@Observes @Initialized ServletContext ctx) {
      em.persist(new Product(1, "Black Hole", 100.0));
   }
}]]></programlisting>
      <para>
         If you'd rather not tie yourself to the Servlet API, you can observe the <literal>WebApplication</literal>
         rather than the <literal>ServletContext</literal>. <literal>WebApplication</literal> is a informational object
         provided by Seam Servlet that holds select information about the <literal>ServletContext</literal> such as the
         application name, context path, server info and start time.
      </para>
      <programlisting role="JAVA"><![CDATA[public void loadData(@Observes @Initialized WebApplication webapp) {
   ...
}]]></programlisting>
      <para>
         You can also use <literal>WebApplication</literal> with the <literal>@Destroyed</literal> qualifier to be
         notified when the web application is stopped.
      </para>
   </section>

   <section id="events.servlet_request_lifecycle_listener">
      <title>Servlet request lifecycle listener</title> 
      <para>
         These events correspond to the <literal>javax.servlet.ServletRequestListener</literal> interface. The event
         object fired is a <literal>javax.servlet.ServletRequest</literal> (since that's the only relevant information
         in the <literal>javax.servlet.ServletRequestEvent</literal> object. There are two qualifiers available that can
         be used for selecting the lifecycle phase of the request (initialize or destroy) and one to filter the observer
         based on the servlet path.
      </para>
      <para>
         <informaltable>
            <tgroup cols="2">
               <colspec colnum="1" colwidth="1*" />
               <colspec colnum="2" colwidth="3*" />
               <thead>
                  <row>
                     <entry>Qualifier</entry>
                     <entry>Description</entry>
                  </row>
               </thead>
               <tbody>
                  <row>
                     <entry>@Initialized</entry>
                     <entry>Qualifies the initialization event</entry>
                  </row>
                  <row>
                     <entry>@Destroyed</entry>
                     <entry>Qualifies the destruction event</entry>
                  </row>
                  <row>
                     <entry>@Path</entry>
                     <entry>Qualifies the servlet path of the request (no leading slash)</entry>
                  </row>
               </tbody>
            </tgroup>
         </informaltable>
      </para>
      <para>
         If you want to listen to both lifecycle events, leave out the qualifiers. 
      </para>
      <programlisting role="JAVA"><![CDATA[public void observeRequest(@Observes ServletRequest request) {
   // Do something with the servlet "request" object
}]]></programlisting>
      <para>
         If you are interested in only a particular one, use a qualifer
      </para>
      <programlisting role="JAVA"><![CDATA[public void observeRequestInitialized(@Observes @Initialized ServletRequest request) {
   // Do something with the servlet "request" object upon initialization
}]]></programlisting>
      <para>
         You can also listen specifically for a <literal>javax.servlet.http.HttpServletRequest</literal>
         simply by changing the expected event type.
      </para>
      <programlisting role="JAVA"><![CDATA[public void observeRequestInitialized(@Observes @Initialized HttpServletRequest request) {
   // Do something with the HTTP servlet "request" object upon initialization
}]]></programlisting>
      <para>
         You can associate an observer with a particular servlet request path (exact match, dropping the leading slash). 
      </para>
      <programlisting role="JAVA"><![CDATA[public void observeRequestInitialized(@Observes @Initialized @Path("offer") HttpServletRequest request) {
   // Do something with the HTTP servlet "request" object upon initialization
   // only when servlet path /offer is requested
}]]></programlisting>
      <para>
         The name of the observer method is insignificant.
      </para>
   </section>

   <section id="events.servlet_response_lifecycle_listener">
      <title>Servlet response lifecycle listener</title> 
      <para>
         The Servlet API does not provide a listener for accessing the lifecycle of a response. Therefore, Seam Servlet
         simulates a response lifecycle listener using CDI events. These events parallel those provided by the
         <literal>javax.servlet.ServletRequestListener</literal> inteface. The event object fired is a
         <literal>javax.servlet.ServletResponse</literal>. There are two qualifiers available that can be used for
         selecting the lifecycle phase of the response (initialize or destroy) and one to filter the observer based on
         the servlet path.
      </para>
      <para>
         <informaltable>
            <tgroup cols="2">
               <colspec colnum="1" colwidth="1*" />
               <colspec colnum="2" colwidth="3*" />
               <thead>
                  <row>
                     <entry>Qualifier</entry>
                     <entry>Description</entry>
                  </row>
               </thead>
               <tbody>
                  <row>
                     <entry>@Initialized</entry>
                     <entry>Qualifies the initialization event</entry>
                  </row>
                  <row>
                     <entry>@Destroyed</entry>
                     <entry>Qualifies the destruction event</entry>
                  </row>
                  <row>
                     <entry>@Path</entry>
                     <entry>Qualifies the servlet path of the request (no leading slash)</entry>
                  </row>
               </tbody>
            </tgroup>
         </informaltable>
      </para>
      <para>
         If you want to listen to both lifecycle events, leave out the qualifiers. 
      </para>
      <programlisting role="JAVA"><![CDATA[public void observeResponse(@Observes ServletResponse response) {
   // Do something with the servlet "response" object
}]]></programlisting>
      <para>
         If you are interested in only a particular one, use a qualifer
      </para>
      <programlisting role="JAVA"><![CDATA[public void observeResponseInitialized(@Observes @Initialized ServletResponse response) {
   // Do something with the servlet "response" object upon initialization
}]]></programlisting>
      <para>
         You can also listen specifically for a <literal>javax.servlet.http.HttpServletResponse</literal>
         simply by changing the expected event type.
      </para>
      <programlisting role="JAVA"><![CDATA[public void observeResponseInitialized(@Observes @Initialized HttpServletResponse response) {
   // Do something with the HTTP servlet "response" object upon initialization
}]]></programlisting>
      <para>
         If you need access to the <literal>ServletRequest</literal> and/or the <literal>ServletContext</literal>
         objects at the same time, you can simply add them as parameters to the observer methods. For instance, let's
         assume you want to manually set the character encoding of the request and response.
      </para>
      <programlisting role="JAVA"><![CDATA[public void setupEncoding(@Observes @Initialized ServletResponse res, ServletRequest req) throws Exception {
   if (this.override || req.getCharacterEncoding() == null) {
      req.setCharacterEncoding(encoding);
      if (override) {
         res.setCharacterEncoding(encoding);
      }
   }
}]]></programlisting>
      <para>
         The name of the observer method is insignificant.
      </para>
      <tip>
         <para>
            If the response is committed by one of the observers, the request will not be sent to the target Servlet and
            the filter chain is skipped.
         </para>
      </tip>
   </section>

   <section id="events.servlet_request_context_lifecycle_listener">
      <title>Servlet request context lifecycle listener</title> 
      <para>
         Rather than having to observe the request and response as separate events, or include the request object as an
         parameter on a response observer, it would be convenient to be able to observe them as a pair. That's why Seam
         Servlet fires an synthetic lifecycle event for the wrapper type <literal>ServletRequestContext</literal>. The
         <literal>ServletRequestContext</literal> holds the <literal>ServletRequest</literal> and the
         <literal>ServletResponse</literal> objects, and also provides access to the <literal>ServletContext</literal>.
         There are two qualifiers available that can be used for selecting the lifecycle phase of the request context
         (initialize or destroy) and one to filter the observer based on the servlet path.
      </para>
      <para>
         <informaltable>
            <tgroup cols="2">
               <colspec colnum="1" colwidth="1*" />
               <colspec colnum="2" colwidth="3*" />
               <thead>
                  <row>
                     <entry>Qualifier</entry>
                     <entry>Description</entry>
                  </row>
               </thead>
               <tbody>
                  <row>
                     <entry>@Initialized</entry>
                     <entry>Qualifies the initialization event</entry>
                  </row>
                  <row>
                     <entry>@Destroyed</entry>
                     <entry>Qualifies the destruction event</entry>
                  </row>
                  <row>
                     <entry>@Path</entry>
                     <entry>Qualifies the servlet path of the request (no leading slash)</entry>
                  </row>
               </tbody>
            </tgroup>
         </informaltable>
      </para>
      <para>
         Let's revisit the character encoding observer and examine how it can be simplified by this event:
      </para>
      <programlisting role="JAVA"><![CDATA[public void setupEncoding(@Observes @Initialized ServletRequestContext ctx) throws Exception {
   if (this.override || ctx.getRequest().getCharacterEncoding() == null) {
      ctx.getRequest().setCharacterEncoding(encoding);
      if (override) {
         ctx.getResponse().setCharacterEncoding(encoding);
      }
   }
}]]></programlisting>
      <para>
         You can also observe the <literal>HttpServletRequestContext</literal> to be notified only on HTTP requests.
      </para>
      <tip>
         <para>
            If the response is committed by one of the observers, the request will not be sent to the target Servlet and
            the filter chain is skipped.
         </para>
      </tip>
      <para>
         Since observers that have access to the response can commit it, an <literal>HttpServletRequestContext</literal>
         observer that receives the initialized event can effectively work as a filter or even a Servlet. Let's consider
         a primitive welcome page filter that redirects visitors to the start page:
      </para>
      <programlisting role="JAVA"><![CDATA[public void redirectToStartPage(@Observes @Path("") @Initialized HttpServletRequestContext ctx)
      throws Exception {
   String startPage = ctx.getResponse().encodeRedirectURL(ctx.getContextPath() + "/start.jsf");
   ctx.getResponse().sendRedirect(startPage);
}]]></programlisting>
      <para>
         Now you never have to write a Servlet listener, Servlet or Filter again!
      </para>
   </section>
   
   <section id="events.session_lifecycle_listener">
      <title>Session lifecycle listener</title> 
      <para>
         These events correspond to the <literal>javax.servlet.HttpSessionListener</literal> interface. The event object
         fired is a <literal>javax.servlet.http.HttpSession</literal> (since that's the only relevant information in the
         <literal>javax.servlet.http.HttpSessionEvent</literal> object). There are two qualifiers available that can be
         used for selecting the lifecycle phase of the session (initialize or destroy).
      </para>
      <para>
         <informaltable>
            <tgroup cols="2">
               <colspec colnum="1" colwidth="1*" />
               <colspec colnum="2" colwidth="3*" />
               <thead>
                  <row>
                     <entry>Qualifier</entry>
                     <entry>Description</entry>
                  </row>
               </thead>
               <tbody>
                  <row>
                     <entry>@Initialized</entry>
                     <entry>Qualifies the creation event</entry>
                  </row>
                  <row>
                     <entry>@Destroyed</entry>
                     <entry>Qualifies the destruction event</entry>
                  </row>
               </tbody>
            </tgroup>
         </informaltable>
      </para>
      <para>
         If you want to listen to both lifecycle events, leave out the qualifiers. Note that omitting all qualifiers
         will observe all events with a <literal>HttpSession</literal> as event object.
      </para>
      <programlisting role="JAVA"><![CDATA[public void observeSession(@Observes HttpSession session) {
   // Do something with the "session" object
}]]></programlisting>
      <para>
         If you are interested in only a particular one, use a qualifer
      </para>
      <programlisting role="JAVA"><![CDATA[public void observeSessionInitialized(@Observes @Initialized HttpSession session) {
   // Do something with the "session" object upon being initialized
}]]></programlisting>
      <para>
         The name of the observer method is insignificant.
      </para>
   </section>

   <section id="events.session_activation_listener">
      <title>Session activation listener</title> 
      <para>
         These events correspond to the
         <literal>javax.servlet.HttpSessionActivationListener</literal> interface. The event object
         fired is a <literal>javax.servlet.http.HttpSession</literal> (since that's the only relevant
         information in the <literal>javax.servlet.http.HttpSessionEvent</literal> object). There
         are two qualifiers available that can be used for selecting the activation or passivation
         of the session.
      </para>
      <para>
         <informaltable>
            <tgroup cols="2">
               <colspec colnum="1" colwidth="1*" />
               <colspec colnum="2" colwidth="3*" />
               <thead>
                  <row>
                     <entry>Qualifier</entry>
                     <entry>Description</entry>
                  </row>
               </thead>
               <tbody>
                  <row>
                     <entry>@DidActivate</entry>
                     <entry>Qualifies the activation event</entry>
                  </row>
                  <row>
                     <entry>@WillPassivate</entry>
                     <entry>Qualifies the passivation event</entry>
                  </row>
               </tbody>
            </tgroup>
         </informaltable>
      </para>
      <para>
         If you want to listen to both lifecycle events, leave out the qualifiers. Note that omitting all qualifiers will
         observe all events with a <literal>HttpSession</literal> as event object.
      </para>
      <programlisting role="JAVA"><![CDATA[public void observeSession(@Observes HttpSession session) {
   // Do something with the "session" object
}]]></programlisting>

      <para>
         If you are interested in only a particular one, use a qualifer
      </para>

      <programlisting role="JAVA"><![CDATA[public void observeSessionCreated(@Observes @WillPassivate HttpSession session) {
   // Do something with the "session" object when it's being passivated
}]]></programlisting>
      <para>
         The name of the observer method is insignificant.
      </para>
   </section>   
   <!--
   <section id="events.asynchronous_listener">
      <title>Servlet context attribute listener</title> 
      <para>
         These events correspond to the <literal>javax.servlet.AsyncListener</literal> interface.
         The event object fired is a <literal>javax.servlet.AsyncEvent</literal>. There are four
         qualifiers available that can be used for selecting the lifecycles of an asynchronous
         event.
      </para>
      <para>
         <informaltable>
            <tgroup cols="2">
               <colspec colnum="1" colwidth="1*" />
               <colspec colnum="2" colwidth="3*" />
               <thead>
                  <row>
                     <entry>Qualifier</entry>
                     <entry>Description</entry>
                  </row>
               </thead>
               <tbody>
                  <row>
                     <entry>@Completed</entry>
                     <entry>Qualifies the completion of a request</entry>
                  </row>
                  <row>
                     <entry>@Error</entry>
                     <entry>Qualifies the error in a request</entry>
                  </row>
                  <row>
                     <entry>@StartAsync</entry>
                     <entry>Qualifies the starting of a request</entry>
                  </row>
                  <row>
                     <entry>@Timeout</entry>
                     <entry>Qualifies the timeout of a request</entry>
                  </row>
               </tbody>
            </tgroup>
         </informaltable>
      </para>
      <para>
         If you want to listen to all asynchronous events, leave out the qualifiers
      </para>
      <programlisting role="JAVA"><![CDATA[public void observeAsyncronousRequest(@Observes AsyncEvent e)
{
   // Do something with the "asynchronous" event object
}]]></programlisting>
      <para>
         If you are interested in only a particular type, use a type qualifer
      </para>
      <programlisting role="JAVA"><![CDATA[public void observeAsyncronousRequestTimedOut(@Observes @Timeout AsyncEvent e)
{
   // Do something with the "request timed out" event object
}]]></programlisting>
      <para>
         The name of the observer method is insignificant.
      </para>
   </section>
   -->
<!--
vim:et:ts=3:sw=3:tw=120
-->
</chapter>
